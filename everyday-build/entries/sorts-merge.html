<!DOCTYPE html>
<html>

<head>
  <title>Merge sort</title>
  <link rel="stylesheet" href="../../css/index.css">
  <link href='https://fonts.googleapis.com/css?family=Signika:300' rel='stylesheet' type='text/css'>
</head>

<body>
  <div class="navbar">
    <span class="navbar-li"><a href="../../index.html">Home</a></span>
    <span class="navbar-li"><a href="../../contact_me.html">Contact Me</a></span>
    <span class="navbar-li"><a href="../index.html">Everyday Build</a></span>
    <span class="navbar-li"><a href="../../projects.html">Projects</a></span>
    <span class="navbar-li-last"><a href="../../resume.html">Resume</a></span>
  </div>

    <main class="section">
      <h2 class="headings">Sorting algorithms: merge sort</h2>
      <h3 class="headings">February 26, 2016</h3>

      <p>This is the fourth in a sorting algorithms series I'm doing to up my CompSci 101
      knowledge! (Previous posts include <a href="sorts-bubble.html">bubble</a> sort,
      <a href="sorts-insertion.html">insertion</a> sort, and <a href="sorts-selection.html">selection</a> sort.)
      <a href="http://www.sorting-algorithms.com/merge-sort">Merge sort</a>, while not
      adaptive to its data, is considered a highly predictable and stable sorting algorithm, with a Big-O notation
      of O(n*lg(n)).</p>
      <script src="https://gist.github.com/mindplace/c7620a8a74a2e85be1b1.js"></script>
      <p>This sort was a difficult one for me to grasp. I understood that initially, the array
      breaks down into slices the size of each single item, then groups slices to their neighbors, swapping their
      immediate positions if the latter is smaller than the former. But that is where my understanding stopped.
      I had to watch <a href="https://www.youtube.com/watch?v=ayN8nBiqg5I">this video on merge sorting</a> to understand
      that as soon as the program compares two groups of items, it basically looks only at the first elements of each
      group. The smaller element is pushed into a sorted list; then the program looks at the new set of first elements, and
      so on, until those sub-groups are empty. At first I didn't understand that because I thought
      that it simply combined them in place. Once I finally understood it though, it immediately became clear
      how to design my algorithm.</p>
      <p>The only bug I needed to understand and fix after that was when it was comparing two sub-slices after the initial
      comparison of their first items. Once it had passed through the slices initially, one of those slices no longer had any
      elements and it broke trying to compare <code>nil</code> to the first element of the second slice. In this case
      as well as in the case of designing the algorithm, it was all a matter of understanding what was happening, and once
      I was able to do that, it was easy to fix.</p>

    </main>
</body>
</html>
